---
title: "Gather KoBoToolbox"
subtitle: "Version `r Sys.time()`"
output: html_document
---

# Purpose

This document describes Rick Gilmore's explorations of the process for downloading and cleaning PLAY Project data from the KoBoToolbox server.

# Setup

The PLAY Project uses KoBoToolbox to collect data from parents and researchers using a tablet application.

The data are stored in an account on <https://kf.kobotoolbox.org>. The login credentials for that account are shared among the PLAY Project staff.

To access the site's API programmatically, an API key was downloaded and added to the local `.Renviron` file.

To test whether the local system has the API key installed, run the following command `Sys.getenv("KOBO_API_KEY")`.

With the API key installed, several custom functions in `R/kobo_files.R` can be run.

## Load/source helper functions

```{r}
source("R/kobo_export.R")
```

## Install dependencies

The helper functions require several external packages. To confirm that these are installed, run the following chunk.

```{r}
install_kobo_packages()
```

## Confirm connection to KoBoToolbox server

We now confirm that we can access data from the server.

```{r}
kb_df <- list_kobo_data()

str(kb_df)
```

This function returns data frame that information about *all* of the forms we have created thus far.

# Exporting files

We are now ready to export data files.

## Demographic questionnaire

We'll focus on the Demographic Questionnaire.

```{r}
kb_demog <- kb_df %>%
  dplyr::filter(., stringr::str_detect(title, "[Dd]emographic"))

kb_demog
```

It looks like there are three of these. Let's download and save the 2nd one, since from the description, it looks like the newer one.
 
```{r}
saved_fn <- retrieve_save_xls_export(2, kb_demog)
```

# Import XLSX

We'll use the `readxl` package to load the saved XLSX file.

```{r}
demog <- readxl::read_excel(saved_fn)
```

Let's list just the questions asked.

```{r}
names(demog)
```

Note that the question names here are more consistently formatted than those from the export form *per se*.

This means that we can come up with functions or filters that 'flag' identifiable data.

```{r}
contains_name <- stringr::str_detect(names(demog), 'name')
contains_address <- stringr::str_detect(names(demog), 'address')
contains_phone <- stringr::str_detect(names(demog), 'phone')
contains_email <- stringr::str_detect(names(demog), 'email')
contains_birthdate <- stringr::str_detect(names(demog), 'birthdate')

identifiable_data <- contains_name | contains_address | contains_phone | contains_email | contains_birthdate
identifiable_cols <- (1:length(names(demog)))[identifiable_data]
 
demog_deidentified <- demog %>%
  dplyr::select(., -all_of(identifiable_cols))

names(demog_deidentified)
```

We can also develop specific 'extraction' functions because the question groups have orderly names.

Here's one for childcare.

### Childcare arrangements

```{r}
child_care_qs <- stringr::str_detect(names(demog), 'child_care')
child_care_cols <- (1:length(names(demog)))[child_care_qs]

play_id_col <- (1:length(names(demog)))[stringr::str_detect(names(demog), 'play_id')]

childcare <- demog %>%
  dplyr::select(., all_of(play_id_col), all_of(child_care_cols)) %>%
  dplyr::rename_with(., basename) # slick way to programmatically rename variables

readr::write_csv(childcare, "tmp/childcare.csv")
```

And another for languages spoken. But these might have to be by target person to avoid duplicates

### Language(s) spoken by mom

```{r}
language_qs <- stringr::str_detect(names(demog), 'language_spoken_mom')
language_cols <- (1:length(names(demog)))[language_qs]

languages_spoken <- demog %>%
  dplyr::select(., all_of(play_id_col), all_of(language_cols)) %>%
  dplyr::rename_with(., basename) # slick way to programmatically rename variables

readr::write_csv(languages_spoken, "tmp/language_spoken_by_mom.csv")
```

### Language(s) spoken to child

```{r}
language_qs <- stringr::str_detect(names(demog), 'language_spoken_child')
language_cols <- (1:length(names(demog)))[language_qs]

languages_spoken <- demog %>%
  dplyr::select(., all_of(play_id_col), all_of(language_cols)) %>%
  dplyr::rename_with(., basename) %>%
  dplyr::rename_with(., ~ paste0(.x, "_to_child"), -contains('play_id')) # slick way to programmatically rename variables

readr::write_csv(languages_spoken, "tmp/language_spoken_to_child.csv")
```

### Languages spoken at home

```{r}
language_qs <- stringr::str_detect(names(demog), 'language_spoken_house')
language_cols <- (1:length(names(demog)))[language_qs]

languages_spoken <- demog %>%
  dplyr::select(., all_of(play_id_col), all_of(language_cols)) %>%
  dplyr::rename_with(., basename) %>%
  dplyr::rename_with(., ~ paste0(.x, "_at_home"), -contains('play_id')) # slick way to programmatically rename variables

readr::write_csv(languages_spoken, "tmp/language_spoken_at_home.csv")
```

### Child info

```{r}
play_id_col <- (1:length(names(demog)))[stringr::str_detect(names(demog), 'play_id')]

child_info_cols <- (1:length(names(demog)))[stringr::str_detect(names(demog), 'child_information')]

child_info <- demog %>%
  dplyr::select(., all_of(play_id_col), all_of(child_info_cols)) %>%
  dplyr::rename_with(., basename) 

readr::write_csv(child_info, "tmp/child_info.csv")
```

### Family structure

```{r}
play_id_col <- (1:length(names(demog)))[stringr::str_detect(names(demog), 'play_id')]

family_structure_cols <- (1:length(names(demog)))[stringr::str_detect(names(demog), 'family_structure')]

child_info <- demog %>%
  dplyr::select(., all_of(play_id_col), all_of(family_structure_cols)) %>%
  dplyr::rename_with(., basename) 

readr::write_csv(child_info, "tmp/family_structure.csv")
```

### Mom info

```{r}
play_id_col <- (1:length(names(demog)))[stringr::str_detect(names(demog), 'play_id')]

mominfo_cols <- (1:length(names(demog)))[stringr::str_detect(names(demog), 'mominfo')]

child_info <- demog %>%
  dplyr::select(., all_of(play_id_col), all_of(family_structure_cols)) %>%
  dplyr::rename_with(., basename) 

readr::write_csv(child_info, "tmp/mom_info.csv")
```

### Biological father info

```{r}
play_id_col <- (1:length(names(demog)))[stringr::str_detect(names(demog), 'play_id')]

mominfo_cols <- (1:length(names(demog)))[stringr::str_detect(names(demog), 'biodad')]

child_info <- demog %>%
  dplyr::select(., all_of(play_id_col), all_of(family_structure_cols)) %>%
  dplyr::rename_with(., basename) 

readr::write_csv(child_info, "tmp/bio_dad_info.csv")
```

### Biological mother info

```{r}
play_id_col <- (1:length(names(demog)))[stringr::str_detect(names(demog), 'play_id')]

mominfo_cols <- (1:length(names(demog)))[stringr::str_detect(names(demog), 'biomom')]

child_info <- demog %>%
  dplyr::select(., all_of(play_id_col), all_of(family_structure_cols)) %>%
  dplyr::rename_with(., basename) 

readr::write_csv(child_info, "tmp/bio_mom_info.csv")
```

### Non-biological partner info

```{r}
play_id_col <- (1:length(names(demog)))[stringr::str_detect(names(demog), 'play_id')]

mominfo_cols <- (1:length(names(demog)))[stringr::str_detect(names(demog), 'nonbiopartner')]

child_info <- demog %>%
  dplyr::select(., all_of(play_id_col), all_of(family_structure_cols)) %>%
  dplyr::rename_with(., basename) 

readr::write_csv(child_info, "tmp/nonbio_partner_info.csv")
```
